self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
self.model.to(self.device)

def trainstep(self, data, target):
    data = data.to(self.device)
    target = target.to(self.device)
    self.model.zero_grad()
    output = self.model(data)
    loss_val = self.loss(output, target)
    loss_val.backward()
    self.optimizer.step()
    return loss_val.item()


def eval_loss(self, dataset):
    trainset = dataset.get_trainset(self.batch_size, self.shuffle)
    epoch_loss = 0.0
    count = 0
    with torch.no_grad():
        for data, target in trainset:
            data = data.to(self.device)
            target = target.to(self.device)
            output = self.model(data)
            loss_val = self.loss(output, target)
            epoch_loss += loss_val.item()
            count += 1
    loss = epoch_loss / count
    logging.info("Loss after iteration: {}".format(loss))
    return loss


  print("Model on device:", next(self.model.parameters()).device)
